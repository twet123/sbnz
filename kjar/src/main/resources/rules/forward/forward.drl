package rules.forward;

import com.ftn.sbnz.model.models.Process;
import com.ftn.sbnz.model.enums.ProcessStatus;
import com.ftn.sbnz.model.models.SystemState;
import com.ftn.sbnz.model.models.CpuCore;
import com.ftn.sbnz.model.enums.CpuCoreStatus;
import com.ftn.sbnz.model.enums.InstructionType;
import com.ftn.sbnz.model.events.CpuTemperatureEvent;
import com.ftn.sbnz.model.events.CpuOverheatEvent;
import com.ftn.sbnz.model.events.IOEvent;
import com.ftn.sbnz.model.events.PageFaultEvent;
import com.ftn.sbnz.model.events.SuspendLowestPriorityProcessEvent;

rule "Schedule process with the highest priority"
    when
        $maxPriority: Number() from accumulate(
            Process(status == ProcessStatus.READY, $priority: priority),
            max($priority)
        )
        $p: Process(status == ProcessStatus.READY, priority == $maxPriority)
        $core: CpuCore(currentProcessId == null, status == CpuCoreStatus.IDLE)
        $ss: SystemState(cpuEnabled == true)
    then
        modify($p) { setStatus(ProcessStatus.RUNNING) }
        modify($core) { setCurrentProcessId($p.getId()), setStatus(CpuCoreStatus.BUSY) }
end

rule "Execute process"
    when
        $p: Process(status == ProcessStatus.RUNNING, currentInstruction < instructions.size())
        $core: CpuCore(currentProcessId == $p.id, status == CpuCoreStatus.BUSY)
        $ss: SystemState(cpuEnabled == true)
    then
        modify($p) { setCurrentInstruction($p.getCurrentInstruction() + 1) }
end

rule "Execute process while paging and not pagingFlag"
    when
        $p: Process(status == ProcessStatus.RUNNING, currentInstruction < instructions.size())
        $core: CpuCore(currentProcessId == $p.id, status == CpuCoreStatus.PAGING, pagingFlag == false)
        $ss: SystemState(cpuEnabled == true)
    then
        modify($core) { setPagingFlag(true) }
end

rule "Execute process while paging and yes pagingFlag"
    when
        $p: Process(status == ProcessStatus.RUNNING, currentInstruction < instructions.size())
        $core: CpuCore(currentProcessId == $p.id, status == CpuCoreStatus.PAGING, pagingFlag == true)
        $ss: SystemState(cpuEnabled == true)
    then
        modify($p) { setCurrentInstruction($p.getCurrentInstruction() + 1) }
        modify($core) { setPagingFlag(false) }
end

rule "Block process on I/O instructions"
salience 3
    when
        $p: Process(status == ProcessStatus.RUNNING,
                    currentInstruction < instructions.size(),
                    $currInstruction: currentInstruction,
                    instructions[$currInstruction] == InstructionType.IO)
        $core: CpuCore(currentProcessId == $p.id, status != CpuCoreStatus.IDLE)
        $ss: SystemState(cpuEnabled == true)
    then
        modify($p) { setStatus(ProcessStatus.BLOCKED) }
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE) }
end

rule "Preemt when there is a process with higher priority"
salience 3
    when
        $p: Process(status == ProcessStatus.RUNNING)
        $pHp: Process(status == ProcessStatus.READY, priority > $p.priority)
        $core: CpuCore(currentProcessId == $p.id, status != CpuCoreStatus.IDLE)
        $ss: SystemState(cpuEnabled == true)
    then
        modify($p) { setStatus(ProcessStatus.READY) }
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE) }
end

rule "Handle suspended process"
    when
        $p: Process(status == ProcessStatus.SUSPENDED)
        $ss: SystemState(availableMemory > $p.safeMemoryLimit)
    then
        modify($p) { setStatus(ProcessStatus.READY) }
end

rule "Return core to normal after paging"
salience 2
    when
        $core: CpuCore(status == CpuCoreStatus.PAGING, System.currentTimeMillis() - lastStatusChange > 2000)
    then
        modify($core) { setStatus(CpuCoreStatus.BUSY), setPagingFlag(false) }
end

rule "Finish executing the process"
salience 5
    when
        $p: Process(status == ProcessStatus.RUNNING, currentInstruction == instructions.size())
        $core: CpuCore(currentProcessId == $p.id, status != CpuCoreStatus.IDLE)
        $ss: SystemState(cpuEnabled == true)
    then
        modify($p) { setStatus(ProcessStatus.EXIT) }
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE) }
        modify($ss) { setAvailableMemory($ss.getAvailableMemory() + $p.getMemoryRequirement()) }
end

rule "Detect CPU overheating"
salience 3
    when
        $criticalTempCount: Number(intValue >= 5) from accumulate(
            $tempEvent: CpuTemperatureEvent(temperature > 100) over window:time(30s),
            count(1)
        )
        $ss: SystemState(cpuEnabled == true)
    then
        modify($ss) { setCpuEnabled(false) }
        insert(new CpuOverheatEvent());
end

rule "Offload cores when overheating"
salience 2
    when
        CpuOverheatEvent()
        $core: CpuCore(status != CpuCoreStatus.IDLE)
        $p: Process(id == $core.currentProcessId, status == ProcessStatus.RUNNING)
    then
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE) }
        modify($p) { setStatus(ProcessStatus.READY) }
end

rule "Enable CPU after cooling down"
    when
        $coolTempCount: Number(intValue >= 5) from accumulate(
            $tempEvent: CpuTemperatureEvent(temperature < 50) over window:time(30s),
            count(1)
        )
        $ss: SystemState(cpuEnabled == false)
    then
        modify($ss) { setCpuEnabled(true) }
end

rule "Handle I/O events"
    when
        $io: IOEvent()
        $p: Process(id == $io.processId, status == ProcessStatus.BLOCKED)
    then
        modify($p) { setStatus(ProcessStatus.READY), setCurrentInstruction($p.getCurrentInstruction() + 1) }
        delete($io);
end

rule "Handle page fault events"
salience 2
    when
        $pf: PageFaultEvent()
        $p: Process(id == $pf.processId, status == ProcessStatus.RUNNING)
        $core: CpuCore(currentProcessId == $p.id, status == CpuCoreStatus.BUSY)
    then
        modify($core) { setStatus(CpuCoreStatus.PAGING) }
end

rule "Detect CPU thrashing"
salience 2
    when
        $pageFaultCount: Number(intValue >= 5) from accumulate(
            PageFaultEvent() over window:time(10s),
            count(1)
        )
        $ss: SystemState(availableMemory < criticalMemoryLimit)
    then
        insert(new SuspendLowestPriorityProcessEvent());
end

rule "Suspend lowest priority process"
salience 2
    when
        SuspendLowestPriorityProcessEvent()
        $minPriority: Number() from accumulate(
            Process(status == ProcessStatus.RUNNING, $priority: priority),
            min($priority)
        )
        $p: Process(status == ProcessStatus.RUNNING, priority == $minPriority)
        $core: CpuCore(currentProcessId == $p.id, status != CpuCoreStatus.IDLE)
    then
        modify($p) { setStatus(ProcessStatus.SUSPENDED) }
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE) }
end

rule "Stop system"
    when
        not Process(status != ProcessStatus.EXIT)
    then
        drools.halt();
end
