package rules.forward;

import com.ftn.sbnz.model.models.Process;
import com.ftn.sbnz.model.enums.ProcessStatus;
import com.ftn.sbnz.model.models.SystemState;
import com.ftn.sbnz.model.models.CpuCore;
import com.ftn.sbnz.model.enums.CpuCoreStatus;
import com.ftn.sbnz.model.enums.InstructionType;
import com.ftn.sbnz.model.events.CpuTemperatureEvent;
import com.ftn.sbnz.model.events.CpuOverheatEvent;
import com.ftn.sbnz.model.events.IOEvent;

rule "Make process ready"
    when
        $p: Process(status == ProcessStatus.NEW)
        $ss: SystemState(availableMemory >= $p.memoryRequirement)
    then
        modify($p) { setStatus(ProcessStatus.READY), setLastStatusChange(System.currentTimeMillis()) }
        modify($ss) { setAvailableMemory($ss.getAvailableMemory() - $p.getMemoryRequirement()) }
end

rule "Schedule process with the highest priority"
    when
        $maxPriority: Number() from accumulate(
            Process(status == ProcessStatus.READY, $priority: priority),
            max($priority)
        )
        $p: Process(status == ProcessStatus.READY, priority == $maxPriority)
        $core: CpuCore(status == CpuCoreStatus.IDLE)
        $ss: SystemState(cpuEnabled == true)
    then
        modify($p) { setStatus(ProcessStatus.RUNNING), setLastStatusChange(System.currentTimeMillis()) }
        modify($core) { setCurrentProcessId($p.getId()), setLastStatusChange(System.currentTimeMillis()), setStatus(CpuCoreStatus.BUSY) }
end

rule "Execute process"
    when
        $p: Process(status == ProcessStatus.RUNNING, currentInstruction < instructions.size())
        $ss: SystemState(cpuEnabled == true)
    then
        modify($p) { setCurrentInstruction($p.getCurrentInstruction() + 1) }
end

rule "Block process on I/O instructions"
salience 3
    when
        $p: Process(status == ProcessStatus.RUNNING, currentInstruction < instructions.size(), $currInstruction: currentInstruction, instructions[$currInstruction] == InstructionType.IO)
        $core: CpuCore(currentProcessId == $p.id, status != CpuCoreStatus.IDLE)
    then
        modify($p) { setStatus(ProcessStatus.BLOCKED), setLastStatusChange(System.currentTimeMillis()) }
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE), setLastStatusChange(System.currentTimeMillis()) }
end

rule "Preemt when there is a process with higher priority"
salience 3
    when
        $p: Process(status == ProcessStatus.RUNNING)
        $pHp: Process(status == ProcessStatus.READY, priority > $p.priority)
        $core: CpuCore(currentProcessId == $p.id, status != CpuCoreStatus.IDLE)
    then
        modify($p) { setStatus(ProcessStatus.READY) }
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE) }
end

rule "Finish executing the process"
salience 5
    when
        $p: Process(status == ProcessStatus.RUNNING, currentInstruction == instructions.size())
        $core: CpuCore(currentProcessId == $p.id, status != CpuCoreStatus.IDLE)
        $ss: SystemState()
    then
        modify($p) { setStatus(ProcessStatus.EXIT), setLastStatusChange(System.currentTimeMillis()) }
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE), setLastStatusChange(System.currentTimeMillis()) }
        modify($ss) { setAvailableMemory($ss.getAvailableMemory() + $p.getMemoryRequirement()) }
end

rule "Detect CPU overheating"
salience 3
    when
        $criticalTempCount: Number(intValue >= 5) from accumulate(
            $tempEvent: CpuTemperatureEvent(temperature > 100) over window:time(30s),
            count(1)
        )
        $ss: SystemState(cpuEnabled == true)
    then
        modify($ss) { setCpuEnabled(false) }
        insert(new CpuOverheatEvent());
end

rule "Offload cores when overheating"
salience 2
    when
        CpuOverheatEvent()
        $core: CpuCore(status != CpuCoreStatus.IDLE)
        $p: Process(id == $core.currentProcessId, status == ProcessStatus.RUNNING)
    then
        //TODO: Modify setter of statuses, so it automatically sets lastStatusChange
        modify($core) { setCurrentProcessId(null), setStatus(CpuCoreStatus.IDLE), setLastStatusChange(System.currentTimeMillis()) }
        modify($p) { setStatus(ProcessStatus.READY), setLastStatusChange(System.currentTimeMillis()) }
end

rule "Enable CPU after cooling down"
    when
        $coolTempCount: Number(intValue >= 5) from accumulate(
            $tempEvent: CpuTemperatureEvent(temperature < 50) over window:time(30s),
            count(1)
        )
        $ss: SystemState(cpuEnabled == false)
    then
        modify($ss) { setCpuEnabled(true) }
end

rule "Handle I/O events"
    when
        $io: IOEvent()
        $p: Process(id == $io.processId, status == ProcessStatus.BLOCKED)
    then
        modify($p) { setStatus(ProcessStatus.READY), setCurrentInstruction($p.getCurrentInstruction() + 1) }
end

rule "Stop system"
    when
        not Process( status != ProcessStatus.EXIT )
    then
        drools.halt();
end
